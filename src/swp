[org 7c00h] ; "origin", bios jumps to 7c00 in memory and executes the first sector if magic bytes are present 512 bytes ahead.
;Begin constants
DISK_LOAD_DL equ 80h ; specifies first disk, e0h means first CD/DVD, 0h is first floppy disk
KERNEL_POSITION equ 0x1000
KERNEL_SIZE     equ 63
;End constants
xor ax, ax
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax
; reset all our segmentation registers. some morbords will do this but some leave them dirty.

; we can get straight to loading the kernel at this point.
; this is programmed to run on a disk, so in qemu we will need to put our code on hard disk
; parameters for int 13h:
;   ah=command (02h is the one we look for)
;   al=sector count
;   ch=cylinder
;   cl=sector
;   dh=head
;   dl=drive
;   the output is at es:bx, which we reset all the segments to 0 so its at its physical address.
mov ah, 2 ; read
mov al, KERNEL_SIZE
xor ch, ch
mov cl, 2 ; sector 2 is the start sector (the one after bootsector)
xor dh, dh
mov dl, DISK_LOAD_DL ; select the drive we want to read from
mov bx, KERNEL_POSITION ; destination address
int 13h

;setting up GDT
cli
;first clear interrupts, can cause unexpected behavior if they are tripped

;the GDTR uses LINEAR memory space, NOT physical. this means we have to account for our data seg. it SHOULD be zero, but if the preceding code is changed it might end up as a different value and thus this code will account for segmentation.
xor eax, eax ; clear eax
mov ax, ds
shl eax,4  ; load in data segment and shift it to be in the correct position (i know its crazy but shifting 4 bits is actually correct)
add eax, GDT_START ; add in our offset, and with this we have our gdtr offset set up in eax.
mov [GDTR_START+2], eax



[section .data]
;Begin data
;Begin GDT
GDTR_START:
GDTR_SIZE: dw 0
GDTR_OFFSET: dd 0

GDTR_END:
GDT_START:
GDT_NULLDESC: dq 0 ; each descriptor 8 bytes, first one is null
GDT_ENT_1:
    GDT_ENT_1_LIMIT0: dw 0xffff ; Descriptor length bits 0-15
    GDT_ENT_1_BASE0: dw 0x1000 ; Descriptor linear base address bits 0-15. the base address is 0x1000
    GDT_ENT_1_BASE1: db 0
    GDT_ENT_1_ACCESSBYTE: db  0b10011100 ; https://wiki.osdev.org/Global_Descriptor_Table, read access byte to know what each flag does
    GDT_ENT_1_LIMIT1_AND_FLAGS: db 0b01000000 ;flags first, then 0s for limit. that gives us 4k to work with in our code segment
    GDT_ENT_1_BASE2: dw 0
    
    GDT_ENT_2_LIMIT0: dw 0xffff 
    GDT_ENT_2_BASE0: dw 0x1000 
    GDT_ENT_2_BASE1: db 1 ;code base address is 0x1000 plus 0xffff limit = 0x11000 base address for next segment
    GDT_ENT_2_ACCESSBYTE: db  0b10011100 ; https://wiki.osdev.org/Global_Descriptor_Table, read access byte to know what each flag does
    GDT_ENT_2_LIMIT1_AND_FLAGS: db 0b01000000 ;flags first, then 0s for limit. that gives us 4k to work with in data seg as well, which we can extend by enabling G flag or adding to limit.
    GDT_ENT_2_BASE2: dw 0
    
GDT_END:
;End GDT
;End data

; send help idk what im doing with all this gdt stuff but this isn't bootable (no way??)
times 510-($-$$) db 0
dw 0xAA55              



;LINKS:
;https://wiki.osdev.org/Global_Descriptor_Table
;https://wiki.osdev.org/GDT_Tutorial#Basics
;https://en.wikipedia.org/wiki/INT_13H
;https://wiki.osdev.org/Segmentation

















[org 0x7c00]

.start:
    mov si, 0 ; x position counter
    mov bx, 0 ; color counter

    ; set video mode 13h (320x200x256)
    mov ah, 0x00
    mov al, 0x13
    int 0x10

.draw:
    cmp si, 320
    je .done

    mov al, [rainbow + bx]
    mov ah, 0x0C
    mov bh, 0x00
    mov cx, si
    mov dx, 15
    int 0x10

    inc si
    inc bx
    cmp bx, rainbow_len
    jne .draw
    mov bx, 0
    jmp .draw

.done:
    jmp $

rainbow db 4,6,14,2,9,5
rainbow_len equ $-rainbow

times 510-($-$$) db 0
dw 0xAA55
